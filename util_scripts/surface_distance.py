import os
import glob
import sys
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))
import numpy as np
import vtk
import utils
import label_io
import marching_cube as m_c
def get_distance_errors(poly_fn, im_fn, ids):
    """
    Map the registered polygon meshes to surfaces generated by marching cube and obtain the distance errors

    Args:
        poly_fn: vtk polydata filename
        im_fn: vtk image filename
        ids: ids of domains to remove
    Return:
        poly: poly with distance error
        avg_error: average error
    """
    gt = label_io.loadVTKMesh(poly_fn) 
    im = label_io.loadLabelMap(im_fn)
    from vtk.util.numpy_support import vtk_to_numpy, numpy_to_vtk
    py_im = vtk_to_numpy(im.GetPointData().GetScalars())
    py_im = utils.swapLabels(py_im)

    for t_id in ids:
        py_im = utils.removeClass(py_im, t_id, 0)
    im.GetPointData().SetScalars(numpy_to_vtk(py_im))

    target = m_c.vtk_marching_cube_multi(im, 0)
    #debug
    locator = utils.pointLocator(target.GetPoints())

    #delete cap 
    face_ids = gt.GetCellData().GetAbstractArray('ModelFaceID')
    print(face_ids)
    gt.BuildLinks()
    for i in range(gt.GetNumberOfCells()):
        if face_ids.GetTuple(i)[0] != 1:
            gt.DeleteCell(i)
    gt.RemoveDeletedCells()
    gt.DeleteLinks()
    err_array = np.zeros(gt.GetNumberOfPoints())
    for i in range(gt.GetNumberOfPoints()):
        pt = gt.GetPoints().GetPoint(i)
        ids = locator.findNClosestPoints(pt, 3)
        avg_pt = (np.array(target.GetPoints().GetPoint(ids.GetId(0)))
        + np.array(target.GetPoints().GetPoint(ids.GetId(1)))
        + np.array(target.GetPoints().GetPoint(ids.GetId(2))))/3.
        err_array[i] = np.linalg.norm(avg_pt-np.array(pt))

    
    return gt, np.mean(err_array)
    

def ground_truth_correction(gt_fn, im_fn, ids):
    """
    Map the registered ground truth images to surfaces generated by marching cube

    Args:
        gt_fn: vtk polydata filename
        im_fn: vtk image filename
        ids: ids of domains to remove
    Return:
        poly: mapped poly
    """
    # read and process image
    print(gt_fn, im_fn)
    gt = label_io.loadVTKMesh(gt_fn) 
    #im = label_io.loadLabelMap(im_fn)
    from image_processing import lvImage
    from vtk.util.numpy_support import vtk_to_numpy, numpy_to_vtk

    im = lvImage(im_fn)
    im.process(ids)
    im.convert2binary()
    im = im.label
    #py_im = vtk_to_numpy(im.GetPointData().GetScalars())
    #py_im = utils.swapLabels(py_im)

    #for t_id in ids:
    #    py_im = utils.removeClass(py_im, t_id, 0)
    
    #im.GetPointData().SetScalars(numpy_to_vtk(py_im))
    

    target = m_c.vtk_marching_cube_multi(im, 0, smooth=20, band=0.02)
    #label_io.writeVTKPolyData(target, os.path.join(os.path.dirname(gt_fn), str(np.random.randint(100))+'.vtk'))
    #debug
    locator = utils.pointLocator(target.GetPoints())

    #delete cap 
    face_ids = gt.GetCellData().GetAbstractArray('ModelFaceID')
    print(face_ids)
    gt.BuildLinks()
    for i in range(gt.GetNumberOfCells()):
        if face_ids.GetTuple(i)[0] != 1:
            gt.DeleteCell(i)
    gt.RemoveDeletedCells()
    gt.DeleteLinks()
    for i in range(gt.GetNumberOfPoints()):
        pt = gt.GetPoints().GetPoint(i)
        ids = locator.findNClosestPoints(pt, 3)
        avg_pt = (np.array(target.GetPoints().GetPoint(ids.GetId(0)))
        + np.array(target.GetPoints().GetPoint(ids.GetId(1)))
        + np.array(target.GetPoints().GetPoint(ids.GetId(2))))/3.
        gt.GetPoints().SetPoint(i, avg_pt)
    
    gt = utils.laplacianSmoothVTKPolydata(gt, 10)
    gt = utils.cleanPolyData(gt, 0.)
    gt = utils.fillHole(gt)
    gt = utils.fixPolydataNormals(gt)
    return gt, im

def map_registered_surface_to_ground_truth():
    #poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results_gt/MACS40282_20150504/surfaces'
    #im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40282_20150504/wall_motion_labels_gt' 
    poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results/MACS40282_20150504/surfaces'
    im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40282_20150504/wall_motion_labels' 
    #poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results_gt/MACS40244_20150309/surfaces'
    #im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40244_20150309/wall_motion_labels_gt' 
    #poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results/MACS40244_20150309/surfaces'
    #im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40244_20150309/wall_motion_labels' 
    poly_dir_out = os.path.join(os.path.dirname(poly_dir), "surfaces_corrected")
    im_dir_out = os.path.join(os.path.dirname(im_dir), "wall_motion_labels_processed")

    try:
        os.makedirs(poly_dir_out)
    except Exception as e: print(e)
    try:
        os.makedirs(im_dir_out)
    except Exception as e: print(e)

    poly_fns = sorted(glob.glob(os.path.join(poly_dir, '*.vtk')))
    im_fns = sorted(glob.glob(os.path.join(im_dir, '*.nii')))
    im_fns += sorted(glob.glob(os.path.join(im_dir, '*.nii.gz')))
    import SimpleITK as sitk
    for poly_fn, im_fn in zip(poly_fns, im_fns):
        gt, im = ground_truth_correction(poly_fn, im_fn, [1, 4, 5, 7]) 
        label_io.writeVTKPolyData(gt, os.path.join(poly_dir_out, os.path.basename(poly_fn)))
        sitk.WriteImage(label_io.exportVTK2Sitk(im), os.path.join(im_dir_out, os.path.basename(im_fn).split('.')[0]+'.nii'))

def calculate_surface_distance_errors():
    #poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results/MACS40282_20150504/surfaces'
    #im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40282_20150504/wall_motion_labels_gt' 
    poly_dir = '/Users/fanweikong/Documents/Modeling/SurfaceModeling/Label_based_results/MACS40244_20150309/surfaces'
    im_dir ='/Users/fanweikong/Documents/ImageData/4DCCTA/MACS40244_20150309/wall_motion_labels_gt' 
    err_out = os.path.join(poly_dir, 'surface_distance_error.txt')

    poly_fns = sorted(glob.glob(os.path.join(poly_dir, '*.vtk')))
    im_fns = sorted(glob.glob(os.path.join(im_dir, '*.nii.gz')))
    err_list = []
    for poly_fn, im_fn in zip(poly_fns, im_fns):
        gt, err  = get_distance_errors(poly_fn, im_fn, [1, 4, 5, 7]) 
        #label_io.writeVTKPolyData(gt, os.path.join(poly_dir_out, os.path.basename(poly_fn)))
        err_list.append(err)

    mean = np.mean(np.array(err_list))
    maximum = np.max(np.array(err_list))
    err_list.append(mean)
    err_list.append(maximum)
    print(err_list)
    np.savetxt(err_out, np.array(err_list).reshape(len(err_list), 1), fmt='%.5f',delimiter=',')

if __name__=='__main__':
    map_registered_surface_to_ground_truth()
    #calculate_surface_distance_errors()

